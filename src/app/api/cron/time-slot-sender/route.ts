import { NextResponse } from 'next/server';
import { db } from '@/db/drizzle';
import { users, settings } from '@/db/schema';
import { eq, ne, notLike, and } from 'drizzle-orm';
import { getTodayDate } from '@/lib/utils';
import { sendConfigEmail, sendConfigWhatsApp } from '@/lib/messaging';
import { updateDailyStatsForUser } from '@/lib/leetcode';

/**
 * TIME-SLOT SENDER CRON JOB  \n * Runs every 30 minutes to send messages to users whose dailyGrindTime falls in current slot\n * Groups users by roast intensity for efficient batch sending\n */\n\n// Helper function to check if a user's dailyGrindTime falls in current 30-minute slot\nfunction isInCurrentTimeSlot(userTime: string | null): boolean {\n  if (!userTime || !userTime.match(/^\\d{2}:\\d{2}$/)) return false;\n  \n  const now = new Date();\n  const currentHour = now.getHours();\n  const currentMinute = now.getMinutes();\n  \n  // Create 30-minute time slots: 00:00-00:30, 00:30-01:00, etc.\n  const slotStart = currentMinute < 30 ? 0 : 30;\n  const slotEnd = slotStart + 30;\n  \n  const [userHour, userMin] = userTime.split(':').map(Number);\n  \n  // Check if user's time falls in current slot\n  return userHour === currentHour && userMin >= slotStart && userMin < slotEnd;\n}\n\n// Helper function to process users in batches with concurrent sending\nasync function processUsersByIntensity(\n  users: any[], \n  intensity: string, \n  message: any,\n  shouldSendEmails: boolean,\n  shouldSendWhatsApp: boolean\n): Promise<any> {\n  const BATCH_SIZE = 10; // Send 10 emails/WhatsApp concurrently\n  \n  const results = {\n    processed: 0,\n    emailsSent: 0,\n    whatsappSent: 0,\n    errors: [] as string[]\n  };\n\n  console.log(`\\nðŸ“§ Processing ${users.length} users with ${intensity} intensity...`);\n  \n  for (let i = 0; i < users.length; i += BATCH_SIZE) {\n    const batch = users.slice(i, i + BATCH_SIZE);\n    console.log(`Processing batch ${Math.floor(i/BATCH_SIZE) + 1}/${Math.ceil(users.length/BATCH_SIZE)} (${batch.length} users)`);\n    \n    // Process all users in batch concurrently\n    const batchPromises = batch.map(async (user) => {\n      try {\n        // Personalize message with user's name\n        const personalizedMessage = message.fullMessage?.replace(/\\[NAME\\]/g, user.name.split(' ')[0]);\n        const personalizedSubject = message.subject?.replace(/\\[NAME\\]/g, user.name.split(' ')[0]);\n        \n        const userResults = {\n          email: { success: false, skipped: true },\n          whatsapp: { success: false, skipped: true },\n          statsUpdate: { success: false }\n        };\n\n        // Update stats (non-blocking)\n        try {\n          await updateDailyStatsForUser(user.id, user.leetcodeUsername);\n          userResults.statsUpdate = { success: true };\n        } catch (error) {\n          console.error(`Stats update failed for ${user.email}:`, error);\n        }\n\n        // Send email if enabled\n        if (shouldSendEmails) {\n          try {\n            const emailResult = await sendConfigEmail(user, undefined, undefined, personalizedMessage);\n            userResults.email = emailResult;\n            if (emailResult.success) results.emailsSent++;\n          } catch (error) {\n            userResults.email = { success: false, error: error instanceof Error ? error.message : 'Email failed' };\n          }\n        }\n\n        // Send WhatsApp if enabled and user has phone\n        if (shouldSendWhatsApp && user.phoneNumber) {\n          try {\n            const whatsappResult = await sendConfigWhatsApp(user, undefined, undefined, personalizedMessage);\n            userResults.whatsapp = whatsappResult;\n            if (whatsappResult.success) results.whatsappSent++;\n          } catch (error) {\n            userResults.whatsapp = { success: false, error: error instanceof Error ? error.message : 'WhatsApp failed' };\n          }\n        }\n\n        results.processed++;\n        return userResults;\n        \n      } catch (error) {\n        const errorMsg = `User ${user.email}: ${error instanceof Error ? error.message : 'Processing failed'}`;\n        results.errors.push(errorMsg);\n        console.error(errorMsg);\n        return null;\n      }\n    });\n\n    // Wait for all users in batch to complete\n    await Promise.allSettled(batchPromises);\n    \n    // Wait 1 second between batches for rate limiting\n    if (i + BATCH_SIZE < users.length) {\n      console.log('Waiting 1 second before next batch...');\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n  }\n  \n  console.log(`âœ… Completed ${intensity}: ${results.emailsSent} emails, ${results.whatsappSent} WhatsApp`);\n  return results;\n}\n\nexport async function GET(req: Request) {\n  const authHeader = req.headers.get('authorization');\n  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n\n  try {\n    const today = getTodayDate();\n    const now = new Date();\n    const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;\n    \n    console.log(`\\nðŸ• Time-slot sender started at ${currentTime}`);\n\n    // Get automation settings and pre-generated messages\n    let [s] = await db.select().from(settings).limit(1);\n    if (!s) {\n      return NextResponse.json({ error: 'Settings not found' }, { status: 404 });\n    }\n\n    // Check automation status\n    if (!s.automationEnabled) {\n      return NextResponse.json({ message: 'Automation disabled', automationEnabled: false });\n    }\n\n    // Get pre-generated messages\n    const aiMessages = s.aiRoast as any;\n    if (!aiMessages || aiMessages.date !== today) {\n      return NextResponse.json({ \n        message: 'No pre-generated messages found for today. Run pre-generation first.',\n        date: today,\n        hasMessages: false\n      });\n    }\n\n    // Check if we have messages for all intensities\n    const availableIntensities = ['mild', 'medium', 'savage'].filter(intensity => \n      aiMessages[intensity] && aiMessages[intensity].fullMessage\n    );\n    \n    if (availableIntensities.length === 0) {\n      return NextResponse.json({ \n        message: 'No valid pre-generated messages available',\n        date: today,\n        availableIntensities: 0\n      });\n    }\n\n    console.log(`Available message intensities: ${availableIntensities.join(', ')}`);\n\n    // Get all users who should receive messages in current time slot\n    // Filter by: non-admin, completed onboarding, has dailyGrindTime set\n    const allUsers = await db.select().from(users)\n      .where(\n        and(\n          ne(users.role, 'admin'),\n          notLike(users.leetcodeUsername, 'pending_%'),\n          eq(users.onboardingCompleted, true)\n        )\n      );\n\n    // Filter users whose dailyGrindTime falls in current 30-minute slot\n    const usersInTimeSlot = allUsers.filter(user => \n      user.dailyGrindTime && isInCurrentTimeSlot(user.dailyGrindTime)\n    );\n\n    if (usersInTimeSlot.length === 0) {\n      return NextResponse.json({ \n        message: 'No users scheduled for current time slot',\n        currentTime,\n        timeSlot: `${currentTime.split(':')[0]}:${now.getMinutes() < 30 ? '00-30' : '30-60'}`,\n        totalUsers: allUsers.length,\n        usersInSlot: 0\n      });\n    }\n\n    console.log(`\\nðŸ“… Found ${usersInTimeSlot.length} users in current time slot`);\n\n    // Group users by roast intensity\n    const usersByIntensity: {[key: string]: any[]} = {\n      mild: [],\n      medium: [],\n      savage: []\n    };\n\n    usersInTimeSlot.forEach(user => {\n      const intensity = user.roastIntensity || 'medium';\n      if (usersByIntensity[intensity]) {\n        usersByIntensity[intensity].push(user);\n      } else {\n        // Fallback to medium if unknown intensity\n        usersByIntensity.medium.push(user);\n      }\n    });\n\n    console.log('Users by intensity:');\n    Object.entries(usersByIntensity).forEach(([intensity, users]) => {\n      if (users.length > 0) {\n        console.log(`  ${intensity}: ${users.length} users`);\n      }\n    });\n\n    // Process each intensity group separately\n    const allResults: any = {\n      totalProcessed: 0,\n      totalEmailsSent: 0,\n      totalWhatsappSent: 0,\n      byIntensity: {} as any,\n      errors: [] as string[]\n    };\n\n    const shouldSendEmails = s.emailAutomationEnabled;\n    const shouldSendWhatsApp = s.whatsappAutomationEnabled;\n\n    for (const intensity of availableIntensities) {\n      const usersForIntensity = usersByIntensity[intensity] || [];\n      \n      if (usersForIntensity.length === 0) {\n        console.log(`â­ï¸  Skipping ${intensity}: no users`);\n        continue;\n      }\n\n      const message = aiMessages[intensity];\n      if (!message || !message.fullMessage) {\n        console.log(`â­ï¸  Skipping ${intensity}: no message available`);\n        continue;\n      }\n\n      try {\n        const results = await processUsersByIntensity(\n          usersForIntensity,\n          intensity,\n          message,\n          shouldSendEmails,\n          shouldSendWhatsApp\n        );\n        \n        allResults.byIntensity[intensity] = results;\n        allResults.totalProcessed += results.processed;\n        allResults.totalEmailsSent += results.emailsSent;\n        allResults.totalWhatsappSent += results.whatsappSent;\n        allResults.errors.push(...results.errors);\n        \n      } catch (error) {\n        const errorMsg = `Failed to process ${intensity} intensity: ${error instanceof Error ? error.message : 'Unknown error'}`;\n        allResults.errors.push(errorMsg);\n        console.error(errorMsg);\n      }\n    }\n\n    // Update settings with sent counts (simplified - you may want more sophisticated tracking)\n    await db.update(settings)\n      .set({\n        emailsSentToday: (s.emailsSentToday || 0) + allResults.totalEmailsSent,\n        whatsappSentToday: (s.whatsappSentToday || 0) + allResults.totalWhatsappSent,\n        lastEmailSent: allResults.totalEmailsSent > 0 ? new Date() : s.lastEmailSent,\n        lastWhatsappSent: allResults.totalWhatsappSent > 0 ? new Date() : s.lastWhatsappSent,\n        updatedAt: new Date()\n      })\n      .where(eq(settings.id, s.id));\n\n    const summary = {\n      currentTime,\n      timeSlot: `${currentTime.split(':')[0]}:${now.getMinutes() < 30 ? '00-30' : '30-60'}`,\n      usersInSlot: usersInTimeSlot.length,\n      processed: allResults.totalProcessed,\n      emailsSent: allResults.totalEmailsSent,\n      whatsappSent: allResults.totalWhatsappSent,\n      intensitiesProcessed: Object.keys(allResults.byIntensity),\n      errorCount: allResults.errors.length\n    };\n\n    console.log(`\\nðŸŽ¯ Time-slot sender completed:`, summary);\n\n    return NextResponse.json({\n      message: 'Time-slot sending completed',\n      summary,\n      detailed: allResults.byIntensity,\n      errors: allResults.errors.length > 0 ? allResults.errors.slice(0, 5) : undefined // Limit error output\n    });\n\n  } catch (error) {\n    console.error('Time-slot sender error:', error);\n    return NextResponse.json({ \n      error: error instanceof Error ? error.message : 'Time-slot sender failed' \n    }, { status: 500 });\n  }\n}